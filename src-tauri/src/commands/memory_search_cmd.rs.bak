//! Memory search commands
//!
//! Provides Tauri commands for semantic and hybrid search

use crate::database::DbConnection;
use proxycast_memory::search;
use proxycast_memory::models::{UnifiedMemory, MemoryCategory};
use proxycast_services::provider_pool_service::ProviderPoolService;
use proxycast_services::api_key_provider_service::ApiKeyProviderService;
use serde::{Deserialize, Serialize};
use tauri::State;

// ==================== Request Types ====================

/// Semantic search options
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SemanticSearchOptions {
    /// Query text
    pub query: String,
    /// Category filter (optional)
    pub category: Option<MemoryCategory>,
    /// Minimum similarity threshold (0.0-1.0, default 0.5)
    pub min_similarity: f32,
    /// Result limit (optional, default 50)
    pub limit: Option<u32>,
}

impl SemanticSearchOptions {
    pub fn with_defaults(mut self) -> Self {
        if self.min_similarity == 0.0 {
            self.min_similarity = 0.5;
        }
        self
    }
}

/// Hybrid search options
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HybridSearchOptions {
    /// Query text
    pub query: String,
    /// Category filter (optional)
    pub category: Option<MemoryCategory>,
    /// Semantic search weight (0.0-1.0, default 0.6)
    pub semantic_weight: f32,
    /// Keyword search weight (automatically calculated as 1.0 - semantic_weight)
    /// Minimum similarity threshold
    pub min_similarity: f32,
    /// Result limit (optional, default 50)
    pub limit: Option<u32>,
}

impl HybridSearchOptions {
    pub fn with_defaults(mut self) -> Self {
        if self.semantic_weight == 0.0 {
            self.semantic_weight = 0.6;
        }
        if self.min_similarity == 0.0 {
            self.min_similarity = 0.5;
        }
        self
    }
}

// ==================== Commands ====================

/// Semantic search (vector similarity)
#[tauri::command]
pub async fn unified_memory_semantic_search(
    db: State<'_, DbConnection>,
    options: SemanticSearchOptions,
) -> Result<Vec<UnifiedMemory>, String> {
    let options = options.with_defaults();

    tracing::info!(
        "[Semantic Search] Query: {}, category: {:?}",
        options.query,
        options.category
    );

    // Use provider pool system to get API key
    let provider_pool_service = ProviderPoolService::new();
    let api_key_service = ApiKeyProviderService::new();

    // Try to get credential from provider pool or fallback to API key provider
    let credential = match provider_pool_service
        .select_credential_with_fallback(
            &db,
            &api_key_service,
            "openai",
            None::<&str>,
            None::<&str>,
            None::<&proxycast_core::models::client_type::ClientType>,
        )
        .await
    {
        Ok(Some(cred)) => cred,
        Ok(None) => {
            return Err(String::from(
                "没有可用的 OpenAI 凭证。请在设置中添加 OpenAI API Key。"
            ));
        }
        Err(e) => return Err(format!("获取凭证失败: {}", e)),
    };

    // Extract API key from credential
    let api_key = match credential.credential {
        proxycast_core::models::provider_pool_model::CredentialData::OpenAIKey {
            api_key,
            ..
        } => api_key,
        proxycast_core::models::provider_pool_model::CredentialData::AnthropicKey {
            api_key,
            ..
        } => api_key,
        _ => {
            return Err(String::from(
                "语义搜索需要 OpenAI API Key 凭证。"
            ));
        }
    };

    tracing::debug!("[Semantic Search] Using API key from provider pool");

    // Get query embedding
    let query_embedding = proxycast_embedding::get_embedding(&options.query, &api_key, None).await
        .map_err(|e| format!("Failed to get embedding: {}", e))?;

    // Execute semantic search
    let results = {
        let conn = db.lock().unwrap();
        search::semantic_search(
            &*conn,
            &query_embedding,
            options.category.as_ref(),
            options.min_similarity,
        )
        .map_err(|e| format!("Semantic search failed: {}", e).to_string())
    }?;

    tracing::info!("[Semantic Search] Returning {} results", results.len());

    Ok(results)
}

/// Hybrid search (semantic + keyword)
#[tauri::command]
pub async fn unified_memory_hybrid_search(

/// Hybrid search (semantic + keyword)
#[tauri::command]
pub async fn unified_memory_hybrid_search(
    db: State<'_, DbConnection>,
    options: HybridSearchOptions,
) -> Result<Vec<UnifiedMemory>, String> {
    let options = options.with_defaults();

    tracing::info!(
        "[Hybrid Search] Query: {}, semantic_weight: {}",
        options.query,
        options.semantic_weight
    );

    // Use provider pool system to get API key
    let provider_pool_service = ProviderPoolService::new();
    let api_key_service = ApiKeyProviderService::new();

    // Try to get credential from provider pool or fallback to API key provider
    let credential = match provider_pool_service
        .select_credential_with_fallback(
            &db,
            &api_key_service,
            "openai",
            None::<&str>,
            None::<&str>,
            None::<&proxycast_core::models::client_type::ClientType>,
        )
        .await
    {
        Ok(Some(cred)) => cred,
        Ok(None) => {
            return Err(String::from(
                "没有可用的 OpenAI 凭证。请在设置中添加 OpenAI API Key。"
            ));
        }
        Err(e) => return Err(format!("获取凭证失败: {}", e)),
    };

    // Extract API key from credential
    let api_key = match credential.credential {
        proxycast_core::models::provider_pool_model::CredentialData::OpenAIKey {
            api_key,
            ..
        } => api_key,
        proxycast_core::models::provider_pool_model::CredentialData::AnthropicKey {
            api_key,
            ..
        } => api_key,
        _ => {
            return Err(String::from(
                "语义搜索需要 OpenAI API Key 凭证。"
            ));
        }
    };

    tracing::debug!("[Hybrid Search] Using API key from provider pool");

    // Get query embedding
    let query_embedding = proxycast_embedding::get_embedding(&options.query, &api_key, None).await
        .map_err(|e| format!("Failed to get embedding: {}", e))?;

    // For now, just return semantic search results
    // TODO: Implement keyword search and merge with weights
    let results = semantic_results;

    tracing::info!("[Hybrid Search] Returning {} results", results.len());

    Ok(results)
}
